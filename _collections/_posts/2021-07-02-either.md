---
title:    'Monada Either - Bezpieczny kod w Haskellu'
author:   TheKamilAdam
category: haskell-eta
langs:    haskell java swift
lib:      
projects: helma helpa
tags:     exception either monad
redirect_from:
- either-monad
- haskell-eta/either-monad
---

Nie lubię wyjątków.
Jest to dotatkowy ukryty przepływ sterowania, a wszystkie przepływy sterowania powinny być jawne.




Niektórzy bronią wyjątków jak niepodległości.


Jak w Haskellu obsługiwać



Monada Either

Either ma dwie wartości
* Prawą poprawną
* Lewą - niepoprawny

Ale jest to uproszczenie.
Po prawej stronie powinna być wartość, którą chcemy dalej przetwarzać za pomocą flatMap.

Można wyobrazić sobie odwrotyny Either (po lewej stronie jest wartość poprawna, po prawej stronie jest wartość niepoprawna).
Dzięki takiej konstrukcji możemy wywoływać po kolej metody aż otrzymamy porpawną wartość
NP
```haskell
callExternalServices params = do
  _ <- callExternalService1 params
  _ <- callExternalService2 params
  _ <- callExternalService3 params
  
```

## Przypadek jednej monady, czlu Safe czyli Either Error

```haskell
type Safe a = Either Error a
type Error = Text
```

```haskell
safe :: a -> Safe a
safe = Right

safeError :: Error -> Safe a
safeError = Left

appendError :: Error -> Safe a -> Safe a
appendError message = first (<> message)
```



```haskell
unsafe :: Safe a -> a
unsafe (Right a) = a
unsafe (Left a) = error a
```

I tu by można skończyć, ale piszemy w Haskellu i potrzebujemu dwóch monad.

## ExceptT - Przypadek dwóch monad, czili Safe i WrapperIO SafeMonadT

W Nieczystycj języmacj programowania jedna metoda Safe wystarczy.
Ale w haskellu potrzubujemy dodatkową monadę do komunikacji ze światem zewnętrnym
Mamy dodatkową monadę WrapperIO

 rezultacie mamy dwie monady i nie możemy ich w prosty sposób składać.
Dlatego potrzebujemy trzeciej monady która jest złożeniem dwóch pozostałych monad

Praca na monadzie `Safe` jest łatwa w czystym (ang. *pure*), funkcyjnym kodzie.
Gdy jednak posiadamy już jakąś monadę do obsługi komunikacji ze światem zewnętrznym sprawa się komplikuje.
Ponieważ dwóch różnych monad nie można łączyć razem za pomocą join czy flatMap.

Dlatego musimy sprowadzić je do wpsólnej postaci.
Pomoże nam w tym monada `ExceptT`.
A dokładniej nasz aliasu typu

```haskell
type SafeMonadT m a = ExceptT Error m a
```

Potrzebujemy jeszcze trzech funkcji do utworzenia naszej monady:
```haskell

hoistMonad :: (Monad m) => m a -> SafeMonadT m a
hoistMonad a = ExceptT $ safe <$> a

--except :: (Monad m) => Either e a -> ExceptT e m a
hoistSafe :: (Monad m) => Safe a -> SafeMonadT m a
hoistSafe = hoistEither
--hoistSafe = except

--hoistError :: (Monad m) => e -> ExceptT e m a
hoistError :: (Monad m) => Error -> SafeMonadT m a
hoistError = hoistSafe . safeError
--hoistError = throwE
```

Funkcje te podnoszą monadę biznesową, `Safe` i `Error` do monady `SafeMonadT`

Potrzebujemy jeszcze 
```haskell


unsafeRunExceptT :: Monad m => SafeMonadT m a -> m a
unsafeRunExceptT = fmap unsafe . runExceptT
```








[Pattern Matching]:            /pattern-matching

[Haskell]:                     /langs/haskell
[Haskella]:                    /langs/haskell
[Haskellu]:                    /langs/haskell

[ClassyPrelude]:               /libs/classy-prelude
[Relude]:                      /libs/relude
[RIO]:                         /libs/rio

[Klasę Typów]:                 /tags/type-class
[Typy zależne]:                /tags/dependent-types
[Wieloparametrowa klasa typu]: /tags/multi-parameter-type-class
[Zalezności funkcyjne]:        /tags/functional-dependencies

[Drop]:       https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Collections/Drop.hs
[Insert]:     https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Collections/Insert.hs
[SplitAt]:    https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Collections/SplitAt.hs
[Pop]:        https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Collections/Pop.hs
[Push]:       https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Collections/Push.hs

[RAM]:        https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Memories/RAM.hs
[Stack]:      https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Memories/Stack.hs
[StackConst]: https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Memories/StackConst.hs
[StackImpl]:  https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Memories/StackImpl.hs
[StackUtil]:  https://github.com/helvm/helma/blob/v0.6.6.0/hs/src/HelVM/HelMA/Common/Memories/StackUtil.hs

[constraint-kinds]:                          http://dev.stephendiehl.com/hask/#constraint-kinds
[Functional dependencies vs. type families]: https://wiki.haskell.org/Functional_dependencies_vs._type_families
