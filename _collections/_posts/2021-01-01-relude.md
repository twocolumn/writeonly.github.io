---
title:    'Alternatywy dla prelude'
author:   TheKamilAdam
category: haskell-eta
tags:     
langs:    Clojure Haskell Scala
libs:     containers relude scalaz
tools:    hlint
projects: helcam helpa
redirect_from:
- relude
- haskell-eta/relude
---


Haskell jest pięknym językiem programowania, ale nie jest doskonały.
Haskell posiada wiele błędów projektowych.

Prelude jest zbiorem domyślnie importowanych


Biblioteka standardowa też nie jest idealna.

Alternatywy dla Prelude próbują to poprawić:

* [relude]
* [protolude]
* [classy-prelude]

Którą bibliotekę wybrać?
* Tą, która ma najwięcej gwiazdek na githubie?
* Tą, która ma najlepszą dokumentację?
* Tą, która ma najlepszą stronę?

Nie jest to ważne.
I tak we wszystkich trzech konkurencjach wygrywa `relude`.

`relude` posiada wiele zalet:

### Minimalizm

Relude stara się być biblioteką minimalistyczną,
czyli zależącą od minimalnej ilości modułów zewnętrznych.
Jest to trudne ponieważ Haskell posiada `base`.
Za małą.




Zależności używane przez Relude znajdują się na [wykresie](https://raw.githubusercontent.com/kowainik/relude/main/relude-dependency-graph.png).

Początkowo może się wydawać że wykres zawiera pół internetu,
ale zależności można podzielić na cztery grupy

Zależności można te podzielić na:
* `text` i `bytestring`, czyli obsługa tekstu.
* `unordered-containers` i `containers`, czyli kontenery (kolekcje). Przy czym `containers` zostało już dodane przez `text`.
* `mtl`, czyli transformatory monad (`ContT`, `ExceptT`, `ListT`, `RWST`, `ReaderT`, `StateT`, `WriterT`) potrzebne każdemu,
  kto chce się zmierzyć z zagnieżdżonymi monadami i stanem
* `stm` czyli legendarna Software Transactional Memory to pamięć transakcyjna używana przy współbieżności,
  która zainspirowała między innymi twórcę języka clojure

Czy to dużo?
W porównaniu z biblioteką standardową wielu innych języków programowania powiedziałbym,
że to mało zdecydowanie za mało.

### Wygoda

Relude skraca czas pisania aplikacji,
ponieważ wiele importów dzieje się automatycznie.
Są to:
* base
* bytestring
* containers
* deepseq
* ghc-prim
* hashable
* mtl
* stm
* text
* transformers
* unordered-containers

bibliotek tych nie należy dodawać samodzielnie tylko używać ich za pośrednictwem Relude.

Są to biblioteki które warto znać.


W moim przypadku było to:
```haskell
import Control.Applicative
import Control.Monad.Except
import Data.Char
import Data.Map.Strict
import Data.Maybe
import Data.Text
import Numeric.Natural
import Text.Read
```

Dodatkowo kolejne funkcjonalności można importować za pomocą `import Relude.Extra`.
Mnie przydały się funkcje `lookup`, `next` i `prev`.

### String vs Text



Domyślnie w Haskellu literały  są typu String, gdzie String to lista znaków:
```haskell
type String = [Char]
```
Jest to powolne i zamiast String należy używać typu `Text`.
Można to zmienić za pomocą przełącznika dla kompilatora `ghc-options: -XOverloadedStrings`.
Można też użyć pragmy kompilatora `{-# LANGUAGE OverloadedStrings #-}`,
ale przełącznik jest lepszym rozwiazaniem,
ponieważ działą we wszystkich plikach
Następnie należy zastąpić wszystkie ewentualne łączenia Stringów za pomocą operatora `++`, operatorem `<>`.
W zasadzie to wszeklie łączenia list operatorem `++` możba zastąpić operatorem `<>`

Niestety `Text` znajduje się w module zewnętrznym `text` a nie module `base` będącym biblioteką standardową.
Relude naprawia ten problem i tak:
*



Text jest zalecany, ale mimo to w haskellu wiele funkcji z biblioteki standardowej pobiera lub zwraca Stringa.

W Relude zostało to znacząco poprawione
np. `show` jest polimorficzny ze względu na typo zwracany,
czyli może wracać zarówno String jak i Text.

Niestety readMaybe i readEither przyjmują dalej `String` zamiast `Text`.


funkcja error przyjmuje Text

-XOverloadedStrings

Dodatkowo mamy miły zestaw funkcji do konwersji między typami.

połączenie tego wszystkiego może sprawić że czasem Haskell nie będzie w stanie wywnioskować typu.
Wszędzie tam gdzie typ jest obojętny powinniśmy używać typu Text


#### Kontenery

W Haskellu są Kontenery a nie kolekcje

https://haskell-containers.readthedocs.io/en/latest/

W Haskellu odwrotnością Lenicych kolekcji (Lazy) są kolekcje Strict






### Programowanie totalne, czyli bezpieczeństwo typów i programowanie totalne

Funkcje powinny być totalne.
To znaczy dla każdego zestawu parametrów zwracać jakąś wartość.
Jeśli funkcja dla jakichś argumentów nie zwraca wartości tylko rzuca wyjątek to jest częściowa,
a nie totalna.
Wiele funkcji z Prelude rzuca wyjątkami.
Relude posiada totalne wersje tych funkcji.

#### NotEmpty

Widziałem już s Scali w Scalaz

#### UnSafe

dalej można korzystać z niebezpiecznych funkcji jeżli użyje się 
```haskell
import qualified Relude.Unsafe as Unsafe
```





### Dokumentacja

https://kodimensional.dev/posts/2019-02-25-haskell-travis#customization-hlint

Hlint jest narzedziem magicznym.
Pozwala napisać kod którego nie jestemy w stanie zrozumieć.
Piszemy kod prosty i długi przy użyciu tylko trywialnych funkcji,
a hint podpowiada jak go skrócić i jednoczęśnie go skomplikować.


https://github.com/kowainik/relude#when-to-use-an-alternative-prelude

## Problemy



## Podsumowanie

Jeszcze nie poznałem wszystkich zalet `relude`.





[relude]:         (https://hackage.haskell.org/package/relude)
[protolude]:      (https://hackage.haskell.org/package/protolude)
[classy-prelude]: (https://hackage.haskell.org/package/classy-prelude)