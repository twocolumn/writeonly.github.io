---
title:    'Alternatywy dla prelude'
author:   TheKamilAdam
category: haskell-eta
tags:     
langs:    Clojure Haskell Scala
libs:     containers relude scalaz
tools:    hlint
projects: helcam helpa
redirect_from:
- relude
- haskell-eta/relude
---


Haskell jest pięknym językiem programowania, ale nie jest doskonały.
Haskell posiada wiele błędów projektowych.

Prelude jest zbiorem domyślnie importowanych


Biblioteka standardowa też nie jest idealna.

Alternatywy dla Prelude próbują to poprawić:

* [relude]
* [protolude]
* [classy-prelude]

Którą bibliotekę wybrać?
* Tą, która ma najwięcej gwiazdek na githubie?
* Tą, która ma najlepszą dokumentację?
* Tą, która ma najlepszą stronę?

Nie jest to ważne.
I tak we wszystkich trzech konkurencjach wygrywa `relude`.

`relude` posiada wiele zalet:

### Programowanie totalne

Funkcje powinny być totalne.
To znaczy dla każdego zestawu parametrów zwracać jakąś wartość.
Jeśli funkcja dla jakichś argumentów nie zwraca wartości, tylko rzuca wyjątek, to jest częściowa,
a nie totalna.
Wiele funkcji z Prelude rzuca wyjątkami.
Relude posiada totalne wersje tych funkcji.

Osiąga to za pomacą promowania:
* funkcji zwracających `Meybe` lub `Either` zamiast rzucania błędami.
* typu `NonEmpty` zamiast `List` tam, gdzie ma to sens.
* nie importowaniu niebezpiecznich funkcji.

Dalej można korzystać z niebezpiecznych funkcji,
jeśli zaimportuje się pakiet `Unsafe`:
```haskell
import qualified Relude.Unsafe as Unsafe
```

### Wydajność

Domyślnie w Haskellu literały tekstowe są typu `String`,
gdzie `String` to lista znaków:
```haskell
type String = [Char]
```
Jest to powolna implementacja napisów i zamiast `String` należy używać typu `Text`.
Można to zmienić za pomocą przełącznika dla kompilatora `ghc-options: -XOverloadedStrings`.
Można też użyć pragmy kompilatora `{-# LANGUAGE OverloadedStrings #-}`,
ale przełącznik jest lepszym rozwiązaniem,
ponieważ działa we wszystkich plikach.

Następnie należy zastąpić wszystkie ewentualne łączenia Stringów za pomocą operatora `++`, operatorem `<>`.
W zasadzie to wszelkie łączenia list operatorem `++` można zastąpić operatorem `<>`.

Niestety `Text` znajduje się w module zewnętrznym `text` a nie module `base` będącym biblioteką standardową.
Text jest zalecany, ale mimo to w haskellu wiele funkcji z biblioteki standardowej pobiera lub zwraca Stringa.

`relude` naprawia ten problem i tak:
* `show` jest polimorficzny ze względu na typo zwracany,
  czyli może wracać zarówno `String` jak i `Text`.
* funkcja error przyjmuje `Text`.

Dodatkowo mamy miły zestaw funkcji do konwersji między typami (`toText`|`toLText`|`toString`).
Dla typu ByteString jest o wieleprostrze do zapamiętania `encodeUtf8`|`decodeUtf8`.


Połączenie tego wszystkiego (przełącznik `-XOverloadedStrings`, funkcja `show`, funkcja `toText` lub `toString`) może sprawić,
że czasem Haskell nie będzie w stanie wywnioskować typu.
Wszędzie tam,
gdzie typ jest obojętny powinniśmy używać typu `Text`.


Niestety readMaybe i readEither przyjmują dalej `String` zamiast `Text`.
Powoduje to że w niektórych przypadkach dalej lepiej używać `Stringa`:

```haskell
readOrError :: Read a => String -> a
readOrError raw = check $ readEither raw where
  check (Right result) = result
  check (Left message) = error $ message <> " [" <> toText raw <> "]"
```


### Wygoda

`relude` skraca czas pisania aplikacji,
ponieważ wiele importów dzieje się automatycznie.
Są to:
* `base`
* `bytestring`
* `containers`
* `deepseq`
* `ghc-prim`
* `hashable`
* `mtl`
* `stm`
* `text`
* `transformers`
* `unordered-containers`

Modułów tych nie należy dodawać samodzielnie tylko używać ich za pośrednictwem `relude`.

Dzięki temu można usunąć z projektu importy wielu modułów.
W moim przypadku było to:
```haskell
import Control.Applicative
import Control.Monad.Except
import Data.Char
import Data.Map.Strict
import Data.Maybe
import Data.Text
import Numeric.Natural
import Text.Read
```

Dodatkowo kolejne funkcjonalności można importować za pomocą `import Relude.Extra`.
Mnie przydały się funkcje `lookup`, `next` i `prev`.




### Minimalizm

Relude stara się być biblioteką minimalistyczną,
czyli zależącą od minimalnej ilości modułów zewnętrznych.
Jest to trudne ponieważ Haskell posiada `base`.
Za małą.

Zależności używane przez Relude znajdują się na [wykresie](https://raw.githubusercontent.com/kowainik/relude/main/relude-dependency-graph.png).

Początkowo może się wydawać,
że wykres zawiera pół internetu,
ale zależności można podzielić na cztery grupy:
* `text` i `bytestring`, czyli obsługa tekstu.
* `unordered-containers` i `containers`, czyli kontenery (kolekcje). Przy czym `containers` zostało już dodane przez `text`.
* `mtl`, czyli transformatory monad (`ContT`, `ExceptT`, `ListT`, `RWST`, `ReaderT`, `StateT`, `WriterT`) potrzebne każdemu,
  kto chce się zmierzyć z zagnieżdżonymi monadami i stanem
* `stm` czyli legendarna Software Transactional Memory to pamięć transakcyjna używana przy współbieżności,
  która zainspirowała między innymi twórcę języka clojure

Czy to dużo?
W porównaniu z biblioteką standardową wielu innych języków programowania powiedziałbym,
że to mało zdecydowanie za mało.




### Dokumentacja

https://kodimensional.dev/posts/2019-02-25-haskell-travis#customization-hlint

Hlint jest narzedziem magicznym.
Pozwala napisać kod którego nie jestemy w stanie zrozumieć.
Piszemy kod prosty i długi przy użyciu tylko trywialnych funkcji,
a hint podpowiada jak go skrócić i jednoczęśnie go skomplikować.


https://github.com/kowainik/relude#when-to-use-an-alternative-prelude

## Podsumowanie

Czy obietnice składane przez twórców `relude` są spełnione?
Uważam,
że tak.


Jeszcze nie poznałem wszystkich zalet `relude`.





[relude]:         (https://hackage.haskell.org/package/relude)
[protolude]:      (https://hackage.haskell.org/package/protolude)
[classy-prelude]: (https://hackage.haskell.org/package/classy-prelude)